<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ç™¾åº¦åœ°å›¾3Dæ¥åŠ›è·¯å¾„è§„åˆ’ï¼ˆWebGLç‰ˆï¼‰</title>
    <script type="text/javascript" src="qwebchannel.js"></script>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
        #mapContainer { width: 100%; height: 100%; }
        .control-btn { position: absolute; top: 50px; left: 10px; z-index: 999; padding: 8px 15px; background: white; border: 1px solid #ccc; cursor: pointer; margin-bottom: 5px; display: block; }
    </style>
</head>
<body>
    <div id="mapContainer"></div>

    <script type="text/javascript">
        var map, walkingRoute;
        var allRoutes = [];
        var allMarkers = [];
        var locateMarker = null;
        var qtBridge;
        var qtRetryCount = 0;
        var qtRetryMax = 500;

        function initBaiduMap() {
            if (!window.BMapGL || !document.getElementById('mapContainer')) {
                setTimeout(initBaiduMap, 100);
                return;
            }

            map = new BMapGL.Map("mapContainer", {
                enableMapClick: true,
                enableHightlight: false
            });
            var defaultCenter = new BMapGL.Point(116.404, 39.915);
            map.centerAndZoom(defaultCenter, 14);
            map.enableScrollWheelZoom(true);

            walkingRoute = new BMapGL.WalkingRoute(map, {
                renderOptions: { autoViewport: false, enableDragging: false }
            });

            initQtWebChannel();
        }

        // é€‚é…å½“å‰æ®µè§†é‡
        function fitSegmentViewport(segmentPoints) {
            if (segmentPoints.length === 0) return;
            map.setViewport(segmentPoints, { margins: [30, 30, 30, 30] });
        }

        function drawGreenRoute(plan) {
            if (!plan) return;

            for (var i = 0; i < plan.getNumRoutes(); i++) {
                var route = plan.getRoute(i);
                var segmentPoints = route.getPath();

                if (segmentPoints.length === 0) continue;

                var newRoute = new BMapGL.Polyline(segmentPoints, {
                    strokeColor: "#00FF00",
                    strokeWeight: 8,
                    strokeOpacity: 1,
                    strokeStyle: "solid",
                    zIndex: 9999
                });

                map.addOverlay(newRoute);
                allRoutes.push(newRoute);
                console.log(`âœ… ç»˜åˆ¶ç¬¬ ${i+1} æ¡å­è·¯çº¿ï¼Œç‚¹æ•°ï¼š${segmentPoints.length}`);

                fitSegmentViewport(segmentPoints);
            }
        }

        function addRelayRouteByAddresses(addresses) {
           if (!Array.isArray(addresses) || addresses.length < 1) {
                alert("è¯·ä¼ å…¥è‡³å°‘åŒ…å«1ä¸ªåœ°å€çš„æ•°ç»„ï¼");
                return;
            }

            const geoCoder = new BMapGL.Geocoder();

            function geocode(address) {
                return new Promise((resolve, reject) => {
                    geoCoder.getPoint(address, (point) => {
                        console.log(`[åœ°ç†ç¼–ç ] ${address} â†’`, point ? `(${point.lng},${point.lat})` : "å¤±è´¥");
                        point ? resolve(point) : reject(`åœ°å€è§£æå¤±è´¥ï¼š${address}`);
                    }, "åŒ—äº¬å¸‚");
                });
            }

            function searchRoute(startPoint, endPoint) {
                return new Promise((resolve, reject) => {
                    console.log(`[è·¯çº¿æœç´¢] å¼€å§‹ï¼š(${startPoint.lng},${startPoint.lat}) â†’ (${endPoint.lng},${endPoint.lat})`);
                    const uniqueCallback = function(results) {
                        walkingRoute.removeEventListener('searchcomplete', uniqueCallback);
                        walkingRoute.setSearchCompleteCallback(null);

                        if (walkingRoute.getStatus() === BMAP_STATUS_SUCCESS) {
                            const plan = results.getPlan(0);
                            drawGreenRoute(plan);
                            resolve(results);
                        } else {
                            reject(`è·¯çº¿è§„åˆ’å¤±è´¥ï¼ˆçŠ¶æ€ç ï¼š${walkingRoute.getStatus()}ï¼‰`);
                        }
                    };

                    walkingRoute.addEventListener('searchcomplete', uniqueCallback);
                    walkingRoute.setSearchCompleteCallback(uniqueCallback);
                    walkingRoute.search(startPoint, endPoint);
                });
            }

            // å·®å¼‚åŒ–æ ‡è®°å‡½æ•°
            function createRelayMarkers(point, labelText, isHighlight = false) {
                var label = new BMapGL.Label(labelText, {
                    position: point,
                    offset: new BMapGL.Size(-15, -15)
                });

                let bgColor = "#ff4444";
                if (labelText.startsWith("æ‹")) bgColor = "#ffa500";
                if (labelText === "ç»ˆ") bgColor = "#0099ff";

                label.setStyle({
                    width: "30px",
                    height: "30px",
                    lineHeight: "30px",
                    textAlign: "center",
                    borderRadius: "50%",
                    backgroundColor: bgColor,
                    color: "white",
                    fontSize: "14px",
                    fontWeight: "bold",
                    border: "2px solid white",
                    boxShadow: "0 2px 4px rgba(0,0,0,0.2)",
                    padding: "0",
                    margin: "0",
                    zIndex: isHighlight ? 10000 : 9999
                });

                map.addOverlay(label);
                allMarkers.push(label);
            }

            async function processSegment(index) {
                if (index >= addresses.length - 1) {
                    console.log("âœ… æ‰€æœ‰å¤šç‚¹æ¥åŠ›è·¯å¾„å¤„ç†å®Œæˆï¼");
                    fitAllRoutesViewport();
                    return;
                }

                try {
                    const startAddr = addresses[index];
                    const endAddr = addresses[index + 1];
                    console.log(`ğŸ”„ å¤„ç†ç¬¬ ${index + 1} æ®µï¼š${startAddr} â†’ ${endAddr}`);

                    const startPoint = await geocode(startAddr);
                    const endPoint = await geocode(endAddr);
                    if (!startPoint || !endPoint) throw new Error("åœ°å€è§£æç»“æœä¸ºç©º");

                    // ç»˜åˆ¶æ ‡è®°
                    if (index === 0) {
                        createRelayMarkers(startPoint, "èµ·", true);
                    }
                    const isFinalEnd = index === addresses.length - 2;
                    const endLabelText = isFinalEnd ? "ç»ˆ" : `æ‹${index + 1}`;
                    createRelayMarkers(endPoint, endLabelText, isFinalEnd);

                    await searchRoute(startPoint, endPoint);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await processSegment(index + 1);
                } catch (error) {
                    console.error(`âŒ ç¬¬ ${index + 1} æ®µå¤±è´¥ï¼š`, error);
                    alert(`ç¬¬ ${index + 1} æ®µå¤±è´¥ï¼š${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await processSegment(index + 1);
                }
            }

            setTimeout(() => processSegment(0), 500);
        }

        function testMultiPointRoute() {
            addRelayRouteByAddresses([
                "åŒ—äº¬å¸‚ä¸œåŸåŒºå¤©å®‰é—¨å¹¿åœº",
                "åŒ—äº¬å¸‚ä¸œåŸåŒºæ•…å®«åšç‰©é™¢",
                "åŒ—äº¬å¸‚ä¸œåŸåŒºç‹åºœäº•æ­¥è¡Œè¡—å—å£",
                "åŒ—äº¬å¸‚æœé˜³åŒºä¸‰é‡Œå±¯å¤ªå¤é‡ŒåŒ—åŒº"
            ]);
        }

        function fitAllRoutesViewport() {
            var allPoints = [];
            allRoutes.forEach(function(route) {
                allPoints = allPoints.concat(route.getPath());
            });
            allMarkers.forEach(function(marker) {
                allPoints.push(marker.getPosition());
            });

            if (allPoints.length > 0) {
                map.setViewport(allPoints, { margins: [50, 50, 50, 50] });
            }
        }

        function clearAllRoutes() {
            allRoutes.forEach(function(route) {
                map.removeOverlay(route);
            });
            allMarkers.forEach(function(marker) {
                map.removeOverlay(marker);
            });
            allRoutes = [];
            allMarkers = [];
            if (locateMarker) {
                map.removeOverlay(locateMarker);
                locateMarker = null;
            }
        }

        function initQtWebChannel() {
            const QWebChannelCtor = window.QWebChannel && (window.QWebChannel.QWebChannel || window.QWebChannel);
            const transportReady = typeof qt !== 'undefined' && qt.webChannelTransport;

            if (!QWebChannelCtor) {
                if (++qtRetryCount > qtRetryMax) {
                    console.error("QWebChannelè„šæœ¬æœªåŠ è½½ï¼Œåœæ­¢é‡è¯•");
                    return;
                }
                console.log("ç­‰å¾…QWebChannelè„šæœ¬åŠ è½½ï¼Œå·²é‡è¯•", qtRetryCount);
                return setTimeout(initQtWebChannel, 100);
            }

            if (!transportReady) {
                if (++qtRetryCount > qtRetryMax) {
                    console.error("Qté€šä¿¡è¶…æ—¶ï¼šæœªæ£€æµ‹åˆ°qt.webChannelTransport");
                    return;
                }
                console.log("ç­‰å¾…Qtæ³¨å…¥webChannelTransportï¼Œå·²é‡è¯•", qtRetryCount);
                return setTimeout(initQtWebChannel, 100);
            }

            console.log("æ£€æµ‹åˆ°QWebChannelä¸Qt transportï¼Œå¼€å§‹å»ºç«‹é€šä¿¡");
            new QWebChannelCtor(qt.webChannelTransport, function(channel) {
                window.routeBridge = channel.objects.routeBridge;
                console.log("Qté€šä¿¡æˆåŠŸï¼šå·²è¿æ¥RouteBridge");

                if (routeBridge.addRelayRouteByAddresses) {
                    routeBridge.addRelayRouteByAddresses.connect(addRelayRouteByAddresses);
                }

                if (routeBridge.addRelayRouteByLngLat) {
                    routeBridge.addRelayRouteByLngLat.connect(addRelayRouteByLngLat);
                }

                if (routeBridge.clearAllRoutes) {
                    routeBridge.clearAllRoutes.connect(clearAllRoutes);
                }

                if (routeBridge.locateByAddress) {
                    routeBridge.locateByAddress.connect(addressToPoint);
                } else {
                    console.warn("routeBridgeç¼ºå°‘locateByAddressä¿¡å·");
                }
            });
        }

        function addressToPoint(address) {
            console.log("å‰ç«¯æ¥æ”¶åˆ°Qtçš„åœ°å€ï¼š", address);

            var localSearch = new BMapGL.LocalSearch(map, {
                pageCapacity: 10,
                onSearchComplete: function() {
                    var status = localSearch.getStatus();
                    if (status === BMAP_STATUS_SUCCESS) {
                        var results = localSearch.getResults();
                        if (results && results.getCurrentNumPois() > 0) {
                            var poi = results.getPoi(0);
                            if (poi && poi.point) {
                                var point = poi.point;
                                map.centerAndZoom(point, 20);
                                map.enableInertialDragging(true);

                                if (locateMarker) map.removeOverlay(locateMarker);
                                locateMarker = new BMapGL.Label("ğŸ“", {
                                    position: point,
                                    offset: new BMapGL.Size(-15, -15)
                                });
                                locateMarker.setStyle({
                                    width: "30px",
                                    height: "30px",
                                    lineHeight: "30px",
                                    textAlign: "center",
                                    borderRadius: "50%",
                                    backgroundColor: "#4cd964",
                                    color: "white",
                                    fontSize: "16px",
                                    border: "2px solid white",
                                    boxShadow: "0 2px 4px rgba(0,0,0,0.2)",
                                    padding: "0",
                                    margin: "0"
                                });
                                map.addOverlay(locateMarker);

                                if (window.routeBridge && routeBridge.receiveLatLng) {
                                    routeBridge.receiveLatLng(address, point.lng, point.lat);
                                }
                                console.log("POIç²¾å‡†å®šä½æˆåŠŸï¼š", address, "â†’", point.lng, point.lat);
                                return;
                            }
                        }
                    }
                    console.warn("POIæœç´¢æ— ç»“æœï¼Œé™çº§ä¸ºåœ°ç†ç¼–ç ");
                    geoCodeFallback(address);
                }
            });

            localSearch.search(address, "åŒ—äº¬å¸‚");
        }

        function geoCodeFallback(address) {
            const myGeo = new BMapGL.Geocoder();
            myGeo.getPoint(address, function(point) {
                if (point) {
                    map.centerAndZoom(point, 19);
                    if (locateMarker) map.removeOverlay(locateMarker);
                    locateMarker = new BMapGL.Label("ğŸ“", {
                        position: point,
                        offset: new BMapGL.Size(-15, -15)
                    });
                    locateMarker.setStyle({
                        width: "30px",
                        height: "30px",
                        lineHeight: "30px",
                        textAlign: "center",
                        borderRadius: "50%",
                        backgroundColor: "#4cd964",
                        color: "white",
                        fontSize: "16px",
                        border: "2px solid white",
                        boxShadow: "0 2px 4px rgba(0,0,0,0.2)",
                        padding: "0",
                        margin: "0"
                    });
                    map.addOverlay(locateMarker);

                    if (window.routeBridge && routeBridge.receiveLatLng) {
                        routeBridge.receiveLatLng(address, point.lng, point.lat);
                    }
                    console.log("åœ°ç†ç¼–ç å®šä½æˆåŠŸï¼š", address, "â†’", point.lng, point.lat);
                } else {
                    alert("åœ°å€è§£æå¤±è´¥ï¼è¯·å°è¯•æ›´å…·ä½“çš„åœ°å€");
                }
            }, "åŒ—äº¬å¸‚");
        }

        window.addressToPoint = addressToPoint;
    </script>

    <script src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=Cr2LMp0XizGpqTAtcE5N6j8V88BhaOZ9&callback=initBaiduMap&t=1735467890" async defer></script>
</body>
</html>
